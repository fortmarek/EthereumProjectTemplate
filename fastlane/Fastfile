

##################################### SETTINGS #####################################

app_language = "English" #CHANGE

app_name_dev = "Sample Testing Δ" # CHANGE
app_name_beta = "Sample Testing β" # CHANGE
app_name_appstore = "Sample Testing" # CHANGE

app_identifier_dev = 'cz.ackee.enterprise.sampletesting.dev' #CHANGE
app_identifier_beta = 'cz.ackee.enterprise.sampletesting.beta' #CHANGE
app_identifier_appstore = 'cz.ackee.SampleTesting' #CHANGE

inhouse_apple_id = 'enterprise@ackee.cz'
inhouse_team_id = 'PXDF48X6VX' 

connect_apple_id = 'ios@ackee.cz' #CHANGE if using client account
connect_team_id = '3SMVP6VZP8' #<-- CHANGE if more team 

slack_url = "https://hooks.slack.com/services/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" #Hook to channel you want to send all messages <-- #rokKvality

hockey_api_token = "90fc8b51202f48bf9aa9772a7238f946" # NOT app id, token for hockey uploads
enterprise_wildcard = "cz.ackee.enterprise.*" # Do not change if you don't have to (We don't want to create provisioning profile for every app)


environment_plist_directory = "Environment"
environment_plist_hockey_key = "hockey_identifier"


production_certificate_git = "git@gitlab.ack.ee:Ackee/ios-production-certificates.git"
inhouse_certificate_git = "git@gitlab.ack.ee:Ackee/ios-inhouse-certificates.git"


####################################################################################



fastlane_version "1.57.0"

	before_all do
		ENV["SLACK_URL"] = slack_url # Webhook URL created in Slack
  end

	desc "Installs FixCode which disables the \"Fix Issue\" button in Xcode"
	  lane :xcode do
	    install_xcode_plugin(
	      url: "https://github.com/fastlane/FixCode/releases/download/0.2.0/FixCode.xcplugin.zip"
	    )
      templates
      snippets
      
	end

  desc "Runs linting (and eventually static analysis)"
  lane :analyze do
  	sh "utils/closure_leak_check.sh ../Source"
    swiftlint
  end

  desc "Runs unit, api and ui tests."
  lane :test do |options|
  	cocoapods
  
    skip_slack = true
    open_report = true
    if is_ci?
      skip_slack = false
      open_report = false
    end

    if options[:type] == "api"
      scheme = "APITests"
    elsif options[:type] == "ui"
      scheme = "UITests"
    elsif options[:type] == "unit"
      scheme = "Development"
    else
      scheme = "AppStore"
    end

    scan(scheme:scheme, skip_slack: skip_slack, open_report: open_report)

  end

 
  desc "Submit new **Beta** build to Hockey app"
  lane :beta do
    #ensure_git_status_clean

  	cocoapods

  	build_number = number_of_commits
		increment_build_number(build_number: build_number)

    produce(
        username: inhouse_apple_id,
        app_identifier: app_identifier_beta,
        app_name: app_name_beta,
        language: app_language,
        team_id: inhouse_team_id,
        skip_itc: true
      )

    #TODO: Change to match later (now limited by 1 certificate)
    sigh(
      username: inhouse_apple_id,
      app_identifier: app_identifier_beta, 
      output_path: "outputs"
    )

    update_project_provisioning(
       profile: lane_context[SharedValues::SIGH_PROFILE_PATH], # Have to pass Profile path to force use this profile instead whatever is set in xcode
       build_configuration: "AdHoc"
     )

    #Setup environments, app identifier and app name
    setup_environment(environment: "AdHoc")

    #Setup badge for beta
    #badge(shield: "#{get_version_number}-#{number_of_commits}-blue", dark: true)

    begin
      gym(
      	scheme: "Development",
  		  configuration: "AdHoc",
        provisioning_profile_path: lane_context[SharedValues::SIGH_PROFILE_PATH],
        export_team_id: inhouse_team_id
  		)

      if !is_ci
        upload_to_hockey(environment: "AdHoc")

        hockey_link = lane_context[SharedValues::HOCKEY_DOWNLOAD_LINK] 

        slack(
            message: "New version uploaded to HockeyApp! #{hockey_link}",
            success: true
          )
      end

    ensure
      #reset badge app icon
      # reset_git_repo( #called only after ensure_git_status_clean
      #   files: [
      #     "./Resources/Images.xcassets/AppIcon.appiconset/"
      # ])
    end

    
  end

  
  desc "Deploy new version to the App Store (and also hockey app)"
  lane :appstore do |options|
      #ensure_git_status_clean
    	cocoapods

    	build_number = number_of_commits
  		increment_build_number(build_number: build_number)

      #Setup environments, app identifier and app name
      setup_environment(environment: "AppStore")

    	#ensure_git_status_clean
  		produce(
  			username: connect_apple_id,
  			app_identifier: app_identifier_appstore,
      	app_name: app_name_appstore,
      	language: app_language,
        team_id: connect_team_id,
        itc_team_id: connect_team_id
      )

      if !options[:skip_snapshot]
        snapshot
      end

      match(
      		username: connect_apple_id,
      		app_identifier: app_identifier_appstore,
          team_id: connect_team_id,
          type: "appstore",
          git_url: production_certificate_git
      	)

      
      # To force provisioning profile on the build we have to update it in the project info file
      # This is necessary because we have two accounts (one for enterprise, one for itunes connect)
      # If somebody picks different team in the xcode project settings it would not build, but crash on entitlements error
      UUID =  ENV["sigh_#{app_identifier_appstore}_appstore"]
      profile = File.expand_path("~/Library/MobileDevice/Provisioning\ Profiles/#{UUID}.mobileprovision") #This is dirty, because Xcode might change location of profiles, but so far only work-around

      update_project_provisioning(
        profile: profile, # Have to pass Profile path to force use this profile instead whatever is set in xcode
        build_configuration: "AppStore"
       )

      gym(
  		  scheme: "AppStore",
        configuration: "AppStore",
  		  clean: true,
  		)
  		
      if !is_ci
  		  upload_to_hockey(environment: "AppStore")
      end

      if is_ci 
        deliver(
      		username: connect_apple_id,
          team_id: connect_team_id,
          force: true
      	)
      else
        deliver(
          username: connect_apple_id,
          team_id: connect_team_id,
        )
      end

      slack(
          message: "Deployed new version to AppStore!",
          success: true
        )


  end

  private_lane :upload_to_hockey do |options|
    # Load hockey app identifier from plist
    hockey_identifier =  get_environment_plist_value(key: environment_plist_hockey_key, environment:options[:environment])

    begin
      if hockey_identifier != ''
        Helper.log.info "Using public_identifier: #{hockey_identifier}"
        
        hockey(
          api_token: hockey_api_token,
          public_identifier: hockey_identifier,
          notify: '0'
        )

      else
        Helper.log.info "No public_identifier found, creating new Hockey app"
        
        hockey(
          api_token: hockey_api_token,
          notify: '0'
        )
      end

    rescue RuntimeError => e
      # When the public_identifier is not found (e.g. App was deleted from hockey app) , try it one more time without it
      if (e.message.include? "not found") && hockey_identifier != ''
        Helper.log.warn "Hockey public_identifier #{hockey_identifier} not found on hockey server (possibly deleted), trying one more time without it"
        
        hockey_identifier = ''
        retry
      else
        raise
      end  
    end

    
    hockey_build = lane_context[SharedValues::HOCKEY_BUILD_INFORMATION] 
    
    #If there is hockey identifier, save it
    hockey_build_public_identifier = hockey_build['public_identifier']

    if  hockey_build_public_identifier &&  hockey_identifier != hockey_build_public_identifier
      Helper.log.info "Saving hockey identifier: #{hockey_build_public_identifier}"
      set_environment_plist_value(key: environment_plist_hockey_key, value: hockey_build_public_identifier, environments: [options[:environment]])

      if is_ci
        #commit and push the saved hockey identifier
        git_commit(path: "./#{environment_plist_directory}/",
          message: "Added hockey identifier (from Fastlane)")

        push_to_git_remote
      end

    end
  end 

  desc "Installs xcode file templates"
  private_lane :templates do |options|
  		#Location of iPhone Templates for reference
  		#/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/
  		install_dir = File.expand_path("~/Library/Developer/Xcode/Templates/File Templates")
  		
  		if ! File.exists? install_dir
  			Helper.log.info "Creating File Template Xcode directory #{install_dir}"
  			FileUtils.mkdir_p install_dir
  		end


		  src_dir = File.expand_path("../userdata/FileTemplates", __FILE__)
		  template_folders = Dir.entries(src_dir)

		  template_folders.each do |template_folder|
		  	template_folder_path = "#{src_dir}/#{template_folder}"

		  	if File.directory?(template_folder_path) 

		  		xctemplates = Dir.entries(template_folder_path).select{ |e| File.extname(e) == ".xctemplate"  }
		  		
		  		install_folder_path = "#{install_dir}/#{template_folder}/"
					FileUtils.mkdir_p install_folder_path

		  		xctemplates.each do |xctemplate|
		  			src_template_path = "#{template_folder_path}/#{xctemplate}"
		  			
		  			if File.exists? "#{install_folder_path}/#{xctemplate}"
		  				Helper.log.info "Removing template #{xctemplate}"
		  				FileUtils.rm_rf "#{install_folder_path}/#{xctemplate}"
		  			end

		  			Helper.log.info "Installing template #{xctemplate} in folder #{install_folder_path}"
		  			FileUtils.cp_r src_template_path, install_folder_path
		  		end

				end 
			end
  end	


  desc "Installs xcode code snippets"
  private_lane :snippets do
    install_dir = File.expand_path("~/Library/Developer/Xcode/UserData/CodeSnippets")
    if ! File.exists? install_dir
        Helper.log.info "Creating Code Snippets Xcode directory #{install_dir}"
        FileUtils.mkdir_p install_dir
      end

      src_dir = File.expand_path("../userdata/CodeSnippets", __FILE__)
      code_snippets =  Dir.entries(src_dir).select{ |e| File.extname(e) == ".codesnippet"  }

      code_snippets.select.each do |snippet|
        src_snippet_path = "#{src_dir}/#{snippet}"

        if File.exists? "#{install_dir}/#{snippet}"
          Helper.log.info "Removing code snippet #{snippet}"
          FileUtils.rm_rf "#{snippet}/#{snippet}"
        end

        Helper.log.info "Installing code snippet #{snippet}"
        FileUtils.cp_r src_snippet_path, install_dir
      end
  end

  desc "Create new screenshots for the App Store in all languages and device types"
  desc "Additionally, this will add device frames around the screenshots"
  lane :screenshots do
    snapshot(skip_open_summary: false)
    frameit(white: true)
  end

  desc "Sets environment.plist app_name and app_bundle_id according to scheme"
  lane :switch_environment do |options|
  	if options[:environment]
      setup_environment(options)
  	else
  		raise "Missing environment: in options"
  	end
  end

  
  # Sets value for given in key in selected environments
  private_lane :set_environment_plist_value do |options|
		options[:environments].each { |env| set_info_plist_value(path: "#{environment_plist_directory}/environment-#{env}.plist", key: options[:key], value: options[:value]) }
  end

  #Gets value for given key in environment
  private_lane :get_environment_plist_value do |options|
  		get_info_plist_value(path: "#{environment_plist_directory}/environment-#{options[:environment]}.plist", key: options[:key])
  end


  desc "Switches environment and sets app_name and app_identifier in plist"
  private_lane :setup_environment do |options|
  		environment = options[:environment]

			display_name = ""
			app_identifier = ""

  		if environment == "AppStore"
  			display_name = app_name_appstore
  			app_identifier = app_identifier_appstore
  		elsif environment == "AdHoc"
  			display_name = app_name_beta
  			app_identifier = app_identifier_beta
  		elsif environment == "Development"
  			display_name = app_name_dev
  			app_identifier = app_identifier_dev
  		else 
  			raise "Non-existent environment: #{environment}"
  		end

  		Helper.log.info "Setting environment for #{environment}"
  		
  		# Change environments according to scheme
			sh "./utils/replace_environment_plist.sh '#{environment}' ../#{environment_plist_directory}/" 

  		Helper.log.info "Setting app name to #{display_name}"
  		Helper.log.info "Setting app identifier to #{app_identifier}"
  		
      update_info_plist(
        plist_path: "Source/Project-Info.plist",
        display_name: display_name
        
      )

      update_app_identifier(
          app_identifier:  app_identifier,
          plist_path: "Source/Project-Info.plist"
      )

			#sh "./utils/generate_preprocess_file.sh '#{display_name}' '#{app_identifier}' ../#{environment_plist_directory}/"
  end

  desc "Copies and renames the project into new directory"
  lane :copy do |options|
    main_dir = File.expand_path("../", File.dirname(__FILE__))

    current_project_file = Dir.entries(main_dir).select{|e| File.extname(e) == ".xcodeproj"}
    if current_project_file.count == 0
      raise ".xcodeproj file not found"
    end 

    current_project_name = File.basename( File.expand_path(current_project_file[0], main_dir), ".*" )

    Helper.log.info "Current project name: #{current_project_name}"

    new_project_name = options[:project_name]
    
    if !new_project_name
      new_project_name = prompt(text: "Please enter new project name:")
    end

    project_path = options[:project_path]
    
   

    begin

      if !project_path
        project_path = prompt(text: "Please enter path for the new project:")
      end

      project_path = File.expand_path(project_path, main_dir)
      
      if ! File.exists? project_path
          Helper.log.info "Creating new project directory #{project_path}"
          FileUtils.mkdir_p project_path
      else
        if !File.directory?(project_path)
          raise "Entered path is not a directory"
        elsif !(Dir.entries(project_path) - %w{ . .. .git .DS_Store }).empty?
          raise "The directory is not empty"
          #print dir_without_hidden
        end
      end

    rescue RuntimeError => e
      Helper.log.warn e.message
      project_path = nil
      retry
    end


    git_repo = options[:git_repo]
    if !git_repo
      git_repo = prompt(text: "Please enter git repository remote:")
    end


    # Copy & clean
    sh "cd ../ && rsync -r . '#{project_path}' && cd #{project_path} && git clean -xdf"

    
    def change_project_name_recursively (path, file_types, replace_from, replace_to)
        
        if File.directory? path
          file_names = (Dir.entries(path) - %w{ . ..})
        else
          file_names = [path]
        end

        file_names.each do |file_name|
          
          file_name = File.expand_path(file_name, path)
          Helper.log.info  "#{file_name}" 
          if !file_types || file_types.include?(File.extname(file_name)) 

            text = File.read(file_name)
            new_contents = text.gsub(/#{replace_from}/, replace_to)

            # To merely print the contents of the file, use:
            #puts new_contents

            # To write changes to the file, use:
            File.open(file_name, "w") {|file| file.puts new_contents }
          elsif File.directory? file_name
            change_project_name_recursively(file_name, file_types, replace_from, replace_to)
          end
      end
    end

    source_file_types = [".swift", ".h", ".m"]

    #Change comments in files
    change_project_name_recursively("#{project_path}/Source/", source_file_types, current_project_name, new_project_name)
    change_project_name_recursively("#{project_path}/Tests/", source_file_types, current_project_name, new_project_name)

    #Change project file and rename it
    change_project_name_recursively("#{project_path}/#{current_project_name}.xcodeproj", [".pbxproj", ".xcscheme"], "SampleTestingProject", new_project_name)
    sh "mv '#{project_path}/#{current_project_name}.xcodeproj' '#{project_path}/#{new_project_name}.xcodeproj'"

    #Remove workspace
    sh "rm -rf '#{project_path}/#{current_project_name}.xcworkspace'"

    #Change project name in podfile
    change_project_name_recursively("#{project_path}/Podfile", nil, current_project_name, new_project_name)
    sh "rm '#{project_path}/Podfile.lock'"

    #Install pods
    sh "cd #{project_path} && pod install"

    #Remove old git
    sh "rm -rf '#{project_path}/.git/'"

    if git_repo
      #Set new git origin
      sh "cd #{project_path} && git init && git add . && git remote add origin '#{git_repo}'"
    end
  end

  after_all do |lane|
    after_success_error(lane: lane)
  end

  error do |lane, exception|
    after_success_error(lane: lane)
    if is_ci
      slack(
        message: exception.message,
        success: false
      )
    end
  end

  private_lane :after_success_error do |options|
    if !is_ci && "#{options[:lane]}" != "switch_environment"
      #Implicitly set environment to Development on local machine
      setup_environment(environment: "Development")
    end

    # if is_ci? && ("#{options[:lane]}" == "appstore" || "#{options[:lane]}" == "beta")
    #   reset_git_repo
    # end
  end


  
#end