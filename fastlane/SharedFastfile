
class Config
  class << self ; 
    attr_accessor :environment_plist_directory ; 
    attr_accessor :inhouse_certificate_git ;  
    attr_accessor :production_certificate_git ; 
    attr_accessor :inhouse_certificate_git ; 
    attr_accessor :enterprise_wildcard ; 
    attr_accessor :hockey_api_token ; 
  end

  @hockey_api_token = "90fc8b51202f48bf9aa9772a7238f946" #API token to hockey app
  @environment_plist_directory = "Environment" #Directory for environment files
  @production_certificate_git = "git@gitlab.ack.ee:Ackee/ios-production-certificates.git" #Match git for production
  @inhouse_certificate_git = "git@gitlab.ack.ee:Ackee/ios-inhouse-certificates.git" #Match git for development 
  @enterprise_wildcard = "cz.ackee.enterprise.*"
  @hockey_api_token = "90fc8b51202f48bf9aa9772a7238f946" # NOT app id, token for hockey uploads
end


fastlane_version "1.57.0"

  #################################
  ###      Default lanes       ####
  #################################

  desc "Installs FixCode which disables the \"Fix Issue\" button in Xcode, Swimat and Fuzzy "
	lane :xcode do
	    install_xcode_plugin(
	      url: "https://github.com/fastlane/FixCode/releases/download/0.2.0/FixCode.xcplugin.zip"
	    )
      install_xcode_plugin(
        url: "https://s3-eu-west-1.amazonaws.com/ack-staticfiles/Swimat.xcplugin.zip"
      )
      
      install_xcode_plugin(
        url: "https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin/releases/download/v2.1.1/FuzzyAutocomplete-2.1.1.zip"
      )
      templates
      snippets
  end


  desc "Runs linting (and eventually static analysis)"
  lane :analyze do
      sh "utils/closure_leak_check.sh ../Source"
      swiftlint
  end

  desc "Runs unit, api and ui tests."
  lane :test do |options|
  	pod_install
  
    skip_slack = true
    open_report = true
    if is_ci?
      skip_slack = false
      open_report = false
    end

    if options[:type] == "api"
      scheme = "APITests"
    elsif options[:type] == "ui"
      scheme = "UITests"
    elsif options[:type] == "unit"
      scheme = "Development"
    else
      scheme = "AppStore"
    end

    scan(scheme:scheme, skip_slack: skip_slack, open_report: open_report)
  end

  desc "Create new screenshots for the App Store in all languages and device types"
  desc "Additionally, this will add device frames around the screenshots"
  lane :screenshots do
    snapshot(skip_open_summary: false)
    frameit(white: true)
  end

  desc "Sets environment.plist app_name and app_bundle_id according to scheme"
  lane :switch_environment do |options|
    if options[:environment]
      setup_environment(options)
    else
      raise "Missing environment: in options"
    end
  end

  desc "Copies and renames the project into new directory"
  lane :copy do |options|
    main_dir = File.expand_path("../", File.dirname(__FILE__))

    current_project_file = Dir.entries(main_dir).select{|e| File.extname(e) == ".xcodeproj"}
    if current_project_file.count == 0
      raise ".xcodeproj file not found"
    end 

    current_project_name = File.basename( File.expand_path(current_project_file[0], main_dir), ".*" )

    UI.message "Current project name: #{current_project_name}"

    new_project_name = options[:project_name]
    
    if !new_project_name
      new_project_name = prompt(text: "Please enter new project name:")
    end

    project_path = options[:project_path]
    
    begin
      if !project_path
        project_path = prompt(text: "Please enter path for the new project:")
      end

      project_path = File.expand_path(project_path, main_dir)
      
      if ! File.exists? project_path
          UI.message "Creating new project directory #{project_path}"
          FileUtils.mkdir_p project_path
      else
        if !File.directory?(project_path)
          raise "Entered path is not a directory"
        elsif !(Dir.entries(project_path) - %w{ . .. .git .DS_Store }).empty?
          raise "The directory is not empty"
        end
      end

    rescue RuntimeError => e
      UI.important e.message
      project_path = nil
      retry
    end


    git_repo = options[:git_repo]
    if !git_repo
      git_repo = prompt(text: "Please enter git repository remote:")
    end


    # Copy & clean
    sh "cd ../ && rsync -r . '#{project_path}' && cd #{project_path} && git clean -xdf"

    
    def change_project_name_recursively (path, file_types, replace_from, replace_to)
        
        if File.directory? path
          file_names = (Dir.entries(path) - %w{ . ..})
        else
          file_names = [path]
        end

        file_names.each do |file_name|
          
          file_name = File.expand_path(file_name, path)
          UI.message  "#{file_name}" 
          if !file_types || file_types.include?(File.extname(file_name)) 

            text = File.read(file_name)
            new_contents = text.gsub(/#{replace_from}/, replace_to)

            File.open(file_name, "w") {|file| file.puts new_contents }
          elsif File.directory? file_name
            change_project_name_recursively(file_name, file_types, replace_from, replace_to)
          end
      end
    end

    source_file_types = [".swift", ".h", ".m"]

    #Change comments in files
    change_project_name_recursively("#{project_path}/Source/", source_file_types, current_project_name, new_project_name)
    change_project_name_recursively("#{project_path}/Tests/", source_file_types, current_project_name, new_project_name)

    #Change project file and rename it
    change_project_name_recursively("#{project_path}/#{current_project_name}.xcodeproj", [".pbxproj", ".xcscheme"], "SampleTestingProject", new_project_name)
    sh "mv '#{project_path}/#{current_project_name}.xcodeproj' '#{project_path}/#{new_project_name}.xcodeproj'"

    #Remove workspace
    sh "rm -rf '#{project_path}/#{current_project_name}.xcworkspace'"

    #Change project name in podfile
    change_project_name_recursively("#{project_path}/Podfile", nil, current_project_name, new_project_name)
    sh "rm '#{project_path}/Podfile.lock'"

    #Install pods
    sh "cd #{project_path} && pod install"

    #Remove old git
    sh "rm -rf '#{project_path}/.git/'"

    if git_repo
      #Set new git origin
      sh "cd #{project_path} && git init && git add . && git remote add origin '#{git_repo}'"
    end
  end

  #################################
  ### Helper methods and lanes ####
  #################################

  ### Hockey app ###
  private_lane :upload_to_hockey do |options|
    hockey_identifier = options[:identifier]

    begin
      if hockey_identifier != ''
        UI.message "Using public_identifier: #{hockey_identifier}"
        
        hockey(
          api_token: Config.hockey_api_token,
          public_identifier: hockey_identifier,
          notify: '0'
        )

      else
        UI.message "No public_identifier found, creating new Hockey app"
        
        hockey(
          api_token: Config.hockey_api_token,
          notify: '0'
        )
      end

    rescue RuntimeError => e
      # When the public_identifier is not found (e.g. App was deleted from hockey app) , try it one more time without it
      if (e.message.include? "not found") && hockey_identifier != ''
        UI.important "Hockey public_identifier #{hockey_identifier} not found on hockey server (possibly deleted), trying one more time without it"
        
        hockey_identifier = ''
        retry
      else
        raise
      end  
    end

    
    hockey_build = lane_context[SharedValues::HOCKEY_BUILD_INFORMATION] 
    
    #If there is hockey identifier, save it
    hockey_build_public_identifier = hockey_build['public_identifier']

    if  hockey_build_public_identifier &&  hockey_identifier != hockey_build_public_identifier
      UI.message "Saving hockey identifier: #{hockey_build_public_identifier}"
      set_environment_plist_value(key: environment_plist_hockey_key, value: hockey_build_public_identifier, environments: [options[:environment]])

      if is_ci
        #commit and push the saved hockey identifier
        git_commit(path: "./#{Config.environment_plist_directory}/",
          message: "Added hockey identifier (from Fastlane)")

        push_to_git_remote
      end

    end
  end 

  ### Templates ###

  desc "Installs xcode file templates"
  private_lane :templates do |options|
  		#Location of iPhone Templates for reference
  		#/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/
  		install_dir = File.expand_path("~/Library/Developer/Xcode/Templates/File Templates")
  		
  		if ! File.exists? install_dir
  			UI.message "Creating File Template Xcode directory #{install_dir}"
  			FileUtils.mkdir_p install_dir
  		end


		  src_dir = File.expand_path("../userdata/FileTemplates", __FILE__)
		  template_folders = Dir.entries(src_dir)

		  template_folders.each do |template_folder|
		  	template_folder_path = "#{src_dir}/#{template_folder}"

		  	if File.directory?(template_folder_path) 

		  		xctemplates = Dir.entries(template_folder_path).select{ |e| File.extname(e) == ".xctemplate"  }
		  		
		  		install_folder_path = "#{install_dir}/#{template_folder}/"
					FileUtils.mkdir_p install_folder_path

		  		xctemplates.each do |xctemplate|
		  			src_template_path = "#{template_folder_path}/#{xctemplate}"
		  			
		  			if File.exists? "#{install_folder_path}/#{xctemplate}"
		  				UI.message "Removing template #{xctemplate}"
		  				FileUtils.rm_rf "#{install_folder_path}/#{xctemplate}"
		  			end

		  			UI.message "Installing template #{xctemplate} in folder #{install_folder_path}"
		  			FileUtils.cp_r src_template_path, install_folder_path
		  		end

				end 
			end
  end	

  ### Snippets

  desc "Installs xcode code snippets"
  private_lane :snippets do
    install_dir = File.expand_path("~/Library/Developer/Xcode/UserData/CodeSnippets")
    if ! File.exists? install_dir
        UI.message "Creating Code Snippets Xcode directory #{install_dir}"
        FileUtils.mkdir_p install_dir
      end

      src_dir = File.expand_path("../userdata/CodeSnippets", __FILE__)
      code_snippets =  Dir.entries(src_dir).select{ |e| File.extname(e) == ".codesnippet"  }

      code_snippets.select.each do |snippet|
        src_snippet_path = "#{src_dir}/#{snippet}"

        if File.exists? "#{install_dir}/#{snippet}"
          UI.message "Removing code snippet #{snippet}"
          FileUtils.rm_rf "#{snippet}/#{snippet}"
        end

        UI.message "Installing code snippet #{snippet}"
        FileUtils.cp_r src_snippet_path, install_dir
      end
  end


  ### Environment helpers ###

  def app_identifier(environment)
    get_environment_plist_value(key: "appIdentifier", environment:environment)
  end

  def app_name(environment)
    get_environment_plist_value(key: "appName", environment:environment)
  end

  def is_environment(environment) 
    return File.file?("../#{Config.environment_plist_directory}/environment-#{environment}.plist")
  end

  # Sets value for given key in selected environments
  private_lane :set_environment_plist_value do |options|
		options[:environments].each { |env| set_info_plist_value(path: "#{Config.environment_plist_directory}/environment-#{env}.plist", key: options[:key], value: options[:value]) }
  end

  #Gets value for given key in environment
  private_lane :get_environment_plist_value do |options|
  		get_info_plist_value(path: "#{Config.environment_plist_directory}/environment-#{options[:environment]}.plist", key: options[:key])
  end


  desc "Switches environment and sets app_name and app_identifier in plist"
  private_lane :setup_environment do |options|
  		environment = options[:environment]

      if !is_environment(environment)
        raise "Unknown environment #{environment}"
      end

			display_name = app_name(environment)
      app_identifier =  app_identifier(environment)

      UI.message "Setting environment for #{environment}"
  		
  		# Change environments according to scheme
			sh "./utils/replace_environment_plist.sh '#{environment}' ../#{Config.environment_plist_directory}/" 

  		UI.message "Setting app name to #{display_name}"
  		UI.message "Setting app identifier to #{app_identifier}"
  		
      update_info_plist(
        plist_path: "Source/Project-Info.plist",
        display_name: display_name
        
      )

      update_app_identifier(
          app_identifier:  app_identifier,
          plist_path: "Source/Project-Info.plist"
      )

			#sh "./utils/generate_preprocess_file.sh '#{display_name}' '#{app_identifier}' ../#{Config.environment_plist_directory}/"
  end

  ### Provisioning ###

  def provisioning_match (environment, match_type, app_identifier, git_url, apple_id, team_id, readonly)
    ENV["MATCH_FORCE_ENTERPRISE"] = "1"

    match(type: match_type,
          app_identifier: app_identifier,
          git_url: git_url,
          username: apple_id,
          team_id: team_id,
          readonly: readonly)

    #Force the selected provisioning profile in xcode
    uuid = ENV["sigh_#{app_identifier}_#{match_type}"]
    profile = File.expand_path("~/Library/MobileDevice/Provisioning\ Profiles/#{uuid}.mobileprovision") 

    update_project_provisioning(
        profile: profile, # Have to pass Profile path to force use this profile instead whatever is set in xcode
        build_configuration: environment
    )
  end


  def provisioning_sigh (environment, sigh_type, app_identifier, apple_id, team_id)
    sigh(
      username: apple_id,
      app_identifier: app_identifier,
      team_id: team_id,
      output_path: "outputs"
    )

    update_project_provisioning(
       profile: lane_context[SharedValues::SIGH_PROFILE_PATH], # Have to pass Profile path to force use this profile instead whatever is set in xcode
       build_configuration: environment
     )
  end

  ### Pods ###

  private_lane :pod_install do
    if is_ci
      puts "Running on CI installing pods with pod repo update"
      sh "pod install --repo-update"
    else
      puts "Running locally pod repo update not neccessary"
      sh "pod install"
    end
  end